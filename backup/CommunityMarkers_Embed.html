<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Community Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .popup-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 0;
      box-shadow: none;
      background: transparent;
      width: 250px;
      font-family: Arial, sans-serif;
    }

    .popup-form input,
    .popup-form textarea,
    .popup-form select {
      width: 100%;
      box-sizing: border-box;
      font-size: 14px;
      padding: 6px;
    }

    .popup-form textarea {
      height: 100px;
      resize: vertical;
    }

    .popup-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .popup-buttons button {
      font-size: 14px;
      padding: 8px 16px;
    }

    @media (min-width: 600px) {
      .popup-buttons {
        flex-direction: row;
        justify-content: flex-start;
      }

      .popup-buttons button {
        width: auto;
      }
    }

    @media (max-width: 599px) {
      .popup-buttons {
        flex-direction: column;
      }

      .popup-buttons button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map("map").setView([39.629152, -79.957313], 14);

// Define map bounds (roughly around Monongalia County)
const bounds = L.latLngBounds(
  [39.431109, -80.405442], // Southwest corner
  [39.735397, -79.731156]  // Northeast corner
);

// Apply bounds to limit panning
map.setMaxBounds(bounds);

// Optionally prevent users from zooming out too far
map.setMinZoom(10);

// Optional: snap back inside bounds if dragged out too fast
map.on('drag', function () {
  map.panInsideBounds(bounds, { animate: false });
});

// Base map layers
const openStreetMap = L.tileLayer(
  "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", 
  { attribution: '© OpenStreetMap contributors' }
);

var esriTopo = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
	      attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
      });

const esri = L.tileLayer(
  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', 
  {
    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
  }
);

// Add default layer
openStreetMap.addTo(map);

// Add layer control
const baseMaps = {
  "OpenStreet Map": openStreetMap,
  "Esri Topo": esriTopo,
  "Esri Imagery": esri
};

L.control.layers(baseMaps).addTo(map);

    window.markers = {};
    let currentUserId = null;
    let isLoggedIn = false;

    function getCategoryIcon(category) {
      let iconUrl;

      switch (category) {
        case 'Walking & Biking':
          iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png';
          break;
        case 'Transit Access & Service':
          iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png';
          break;
        case 'Road & Traffic':
          iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png';
          break;
        default:
          iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png';
      }

      return L.icon({
        iconUrl: iconUrl,
        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });
    }

    function addMarkerToMap(marker) {
      const icon = getCategoryIcon(marker.category);
      const leafletMarker = L.marker([marker.lat, marker.lng], { icon: icon }).addTo(map);
      window.markers[marker._id] = leafletMarker;

      let popupContent = `<b>${marker.tit}</b><br>${marker.des}<br><br><br><i>${marker.category}</i>`;
      if (currentUserId && marker.ownerId === currentUserId) {
        popupContent += `<br><button onclick="deleteMarker('${marker._id}')">Delete</button>`;
      }

      leafletMarker.bindPopup(popupContent);
      leafletMarker.on("click", () => leafletMarker.openPopup());
    }

    function createInputPopup(lat, lng) {
      const popupContent = document.createElement('div');
      popupContent.className = 'popup-form';

      const titleInput = document.createElement('input');
      titleInput.placeholder = 'Title';

      const descInput = document.createElement('textarea');
      descInput.placeholder = 'Description';

      const categorySelect = document.createElement('select');
      categorySelect.id = 'category-select';

      const option1 = new Option('🚶‍♀️ Walking & Biking', 'Walking & Biking');
      const option2 = new Option('🚌 Transit Access & Service', 'Transit Access & Service');
      const option3 = new Option('🚗 Road & Traffic', 'Road & Traffic');

      categorySelect.append(option1, option2, option3);

      const saveBtn = document.createElement('button');
      saveBtn.innerText = 'Save';
      saveBtn.disabled = true;
      saveBtn.style.opacity = '0.5';

      const cancelBtn = document.createElement('button');
      cancelBtn.innerText = 'Cancel';

      const btnWrapper = document.createElement('div');
      btnWrapper.className = 'popup-buttons';
      btnWrapper.appendChild(saveBtn);
      btnWrapper.appendChild(cancelBtn);

      popupContent.append(titleInput, descInput, categorySelect, btnWrapper);

      const popup = L.popup()
        .setLatLng([lat, lng])
        .setContent(popupContent)
        .openOn(map);

      function validateInputs() {
        const hasTitle = titleInput.value.trim().length > 0;
        const hasDesc = descInput.value.trim().length > 0;
        saveBtn.disabled = !(hasTitle && hasDesc);
        saveBtn.style.opacity = saveBtn.disabled ? '0.5' : '1';
      }

      titleInput.addEventListener('input', validateInputs);
      descInput.addEventListener('input', validateInputs);

      cancelBtn.onclick = () => map.closePopup();

      saveBtn.onclick = () => {
        const markerData = {
          tit: titleInput.value,
          des: descInput.value,
          lat,
          lng,
          category: categorySelect.value
        };

        parent.postMessage({ type: "saveMarker", data: markerData }, "*");
        map.closePopup();
      };
    }

    function deleteMarker(id) {
      parent.postMessage({ type: "deleteMarker", data: id }, "*");
    }

    map.on("click", (e) => {
      const { lat, lng } = e.latlng;

      if (!isLoggedIn) {
        const loginPopupContent = `
          <div style="text-align:center;">
            <b>You must log in to create markers.</b><br><br>
            <button onclick="parent.postMessage({ type: 'requestLogin' }, '*')">Log In</button>
          </div>
        `;

        L.popup()
          .setLatLng([lat, lng])
          .setContent(loginPopupContent)
          .openOn(map);
        return;
      }

      createInputPopup(lat, lng);
    });

    window.addEventListener("message", (event) => {
      const { type, data } = event.data;

      if (type === "userInfo") {
        isLoggedIn = data.isLoggedIn;
        currentUserId = data.userId;
      }

      if (type === "markersLoaded") {
        data.forEach(addMarkerToMap);
      }

      if (type === "markerSaved") {
        addMarkerToMap(data);
      }

      if (window.markers[data]) {
        map.removeLayer(window.markers[data]);
        delete window.markers[data];
      }
    });

    parent.postMessage({ type: "loadMarkers" }, "*");
  </script>
</body>
</html>
